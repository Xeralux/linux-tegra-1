/*
 * Copyright (c) 2018 Verizon Communications, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "dt-bindings/clock/tegra186-clock.h"

#define CAM0_RST_L	TEGRA_MAIN_GPIO(R, 5)
#define CAM0_PWDN	TEGRA_MAIN_GPIO(R, 0)
#define CAM1_RST_L	TEGRA_MAIN_GPIO(R, 1)
#define CAM1_PWDN	TEGRA_MAIN_GPIO(N, 2)


/* camera control gpio definitions */
/ {

	/* camera 0 at 2-001a */
	i2c@3180000 {
		status = "okay";

		imx185_cam0: imx185_a@1a {
			compatible = "nvidia,imx185";
			status = "disabled";
			reg = <0x1a>;

			clocks = <&tegra_car TEGRA186_CLK_EXTPERIPH1>,
					 <&tegra_car TEGRA186_CLK_PLLP_OUT0>;
			clock-names = "extperiph1", "pllp_grtba";
			mclk = "extperiph1";
			clock-frequency = <24000000>;
			reset-gpios = <&tegra_main_gpio CAM0_RST_L GPIO_ACTIVE_HIGH>;
			pwdn-gpios = <&tegra_main_gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;

			/* Physical dimensions of sensor */
			physical_w = "3.674";
			physical_h = "2.738";

			sensor_model = "imx185";
			/* Define any required hw resources needed by driver */
			/* ie. clocks, io pins, power sources */
			devnode = "video0";

			/* Defines number of frames to be dropped by driver internally after applying */
			/* sensor crop settings. Some sensors send corrupt frames after applying */
			/* crop co-ordinates */
			post_crop_frame_drop = "0";
			/* if true, delay gain setting by one frame to be in sync with exposure */
			/* delayed_gain = "true"; */

			/**
			* A modeX node is required to support v4l2 driver
			* implementation with NVIDIA camera software stack
			*
			* mclk_khz = "";
			* Standard MIPI driving clock, typically 24MHz
			*
			* num_lanes = "";
			* Number of lane channels sensor is programmed to output
			*
			* tegra_sinterface = "";
			* The base tegra serial interface lanes are connected to
			*
			* discontinuous_clk = "";
			* The sensor is programmed to use a discontinuous clock on MIPI lanes
			*
			* dpcm_enable = "true";
			* The sensor is programmed to use a DPCM modes
			*
			* cil_settletime = "";
			* MIPI lane settle time value.
			* A "0" value attempts to autocalibrate based on mclk_multiplier
			*
			* active_w = "";
			* Pixel active region width
			*
			* active_h = "";
			* Pixel active region height
			*
			* dynamic_pixel_bit_depth = "";
			* sensor dynamic bit depth for sensor mode
			*
			* csi_pixel_bit_depth = "";
			* sensor output bit depth for sensor mode
			*
			* mode_type="";
			* Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
			*
			* pixel_phase="";
			* Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
			*
			* readout_orientation = "0";
			* Based on camera module orientation.
			* Only change readout_orientation if you specifically
			* Program a different readout order for this mode
			*
			* line_length = "";
			* Pixel line length (width) for sensor mode.
			* This is used to calibrate features in our camera stack.
			*
			* mclk_multiplier = "";
			* Multiplier to MCLK to help time hardware capture sequence
			* TODO: Assign to PLL_Multiplier as well until fixed in core
			*
			* pix_clk_hz = "";
			* Sensor pixel clock used for calculations like exposure and framerate
			*
			*
			*
			*
			* inherent_gain = "";
			* Gain obtained inherently from mode (ie. pixel binning)
			*
			* min_gain_val = ""; (floor to 6 decimal places)
			* max_gain_val = ""; (floor to 6 decimal places)
			* Gain limits for mode
			* if use_decibel_gain = "true", please set the gain as decibel
			*
			* min_exp_time = ""; (ceil to integer)
			* max_exp_time = ""; (ceil to integer)
			* Exposure Time limits for mode (us)
			*
			*
			* min_hdr_ratio = "";
			* max_hdr_ratio = "";
			* HDR Ratio limits for mode
			*
			* min_framerate = "";
			* max_framerate = "";
			* Framerate limits for mode (fps)
			*
			* embedded_metadata_height = "";
			* Sensor embedded metadata height in units of rows.
			* If sensor does not support embedded metadata value should be 0.
			*/
			mode0 {/*mode IMX185_MODE_1920X1080_CROP_30FPS*/
					mclk_khz = "37125";
					num_lanes = "4";
					tegra_sinterface = "serial_a";
					discontinuous_clk = "no";
					dpcm_enable = "false";
					cil_settletime = "0";
					dynamic_pixel_bit_depth = "12";
					csi_pixel_bit_depth = "12";
					mode_type = "bayer";
					pixel_phase = "rggb";

					active_w = "1920";
					active_h = "1080";
					readout_orientation = "0";
					line_length = "2200";
					inherent_gain = "1";
					mclk_multiplier = "2";
					pix_clk_hz = "74250000";

					min_gain_val = "0"; /* dB */
					max_gain_val = "48"; /* dB */
					min_hdr_ratio = "1";
					max_hdr_ratio = "1";
					min_framerate = "1.5";
					max_framerate = "30";
					min_exp_time = "30";
					max_exp_time = "660000";
					embedded_metadata_height = "1";
			};
			mode1 {/*mode IMX185_MODE_1920X1200_30FPS*/
						mclk_khz = "37125";
						num_lanes = "4";
						tegra_sinterface = "serial_a";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "12";
						csi_pixel_bit_depth = "12";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1200";
						readout_orientation = "0";
						line_length = "3750";
						inherent_gain = "1";
						mclk_multiplier = "4";
						pix_clk_hz = "148500000";

						min_gain_val = "0";
						max_gain_val = "48";
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1.5";
						max_framerate = "30";
						min_exp_time = "30";
						max_exp_time = "660000";
						embedded_metadata_height = "1";
			};
			ports {
				#address-cells = <1>;
				#size-cells = <0>;
				port@0 {
					reg = <0>;
					imx185_out0: endpoint {
						csi-port = <0>;
						bus-width = <4>;
						remote-endpoint = <&csi_in0>;
					};
				};
			};
		};
	};

	/* camera 1 at 7-001a */
	i2c@c250000 {
		status = "okay";

		imx185_cam1: imx185_c@1a {
			compatible = "nvidia,imx185";
			status = "disabled";
			reg = <0x1a>;

			clocks = <&tegra_car TEGRA186_CLK_EXTPERIPH2>,
					 <&tegra_car TEGRA186_CLK_PLLP_OUT0>;
			clock-names = "extperiph2", "pllp_grtba";
			mclk = "extperiph2";
			clock-frequency = <24000000>;
			reset-gpios = <&tegra_main_gpio CAM1_RST_L GPIO_ACTIVE_HIGH>;
			pwdn-gpios = <&tegra_main_gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;

			/* Physical dimensions of sensor */
			physical_w = "3.674";
			physical_h = "2.738";
			sensor_model = "imx185";
			/* Define any required hw resources needed by driver */
			/* ie. clocks, io pins, power sources */
			devnode = "video1";

			/* Defines number of frames to be dropped by driver internally after applying */
			/* sensor crop settings. Some sensors send corrupt frames after applying */
			/* crop co-ordinates */
			post_crop_frame_drop = "0";

			/**
			* A modeX node is required to support v4l2 driver
			* implementation with NVIDIA camera software stack
			*
			* mclk_khz = "";
			* Standard MIPI driving clock, typically 24MHz
			*
			* num_lanes = "";
			* Number of lane channels sensor is programmed to output
			*
			* tegra_sinterface = "";
			* The base tegra serial interface lanes are connected to
			*
			* discontinuous_clk = "";
			* The sensor is programmed to use a discontinuous clock on MIPI lanes
			*
			* dpcm_enable = "true";
			* The sensor is programmed to use a DPCM modes
			*
			* cil_settletime = "";
			* MIPI lane settle time value.
			* A "0" value attempts to autocalibrate based on mclk_multiplier
			*
			* active_w = "";
			* Pixel active region width
			*
			* active_h = "";
			* Pixel active region height
			*
			* dynamic_pixel_bit_depth = "";
			* sensor dynamic bit depth for sensor mode
			*
			* csi_pixel_bit_depth = "";
			* sensor output bit depth for sensor mode
			*
			* mode_type="";
			* Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
			*
			* pixel_phase="";
			* Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
			*
			* readout_orientation = "0";
			* Based on camera module orientation.
			* Only change readout_orientation if you specifically
			* Program a different readout order for this mode
			*
			* line_length = "";
			* Pixel line length (width) for sensor mode.
			* This is used to calibrate features in our camera stack.
			*
			* mclk_multiplier = "";
			* Multiplier to MCLK to help time hardware capture sequence
			* TODO: Assign to PLL_Multiplier as well until fixed in core
			*
			* pix_clk_hz = "";
			* Sensor pixel clock used for calculations like exposure and framerate
			*
			*
			*
			*
			* inherent_gain = "";
			* Gain obtained inherently from mode (ie. pixel binning)
			*
			* min_gain_val = ""; (floor to 6 decimal places)
			* max_gain_val = ""; (floor to 6 decimal places)
			* Gain limits for mode
			* if use_decibel_gain = "true", please set the gain as decibel
			*
			* min_exp_time = ""; (ceil to integer)
			* max_exp_time = ""; (ceil to integer)
			* Exposure Time limits for mode (us)
			*
			*
			* min_hdr_ratio = "";
			* max_hdr_ratio = "";
			* HDR Ratio limits for mode
			*
			* min_framerate = "";
			* max_framerate = "";
			* Framerate limits for mode (fps)
			*
			* embedded_metadata_height = "";
			* Sensor embedded metadata height in units of rows.
			* If sensor does not support embedded metadata value should be 0.
			*/
			mode0 {/*mode IMX185_MODE_1920X1080_CROP_30FPS*/
					mclk_khz = "37125";
					num_lanes = "4";
					tegra_sinterface = "serial_c";
					discontinuous_clk = "no";
					dpcm_enable = "false";
					cil_settletime = "0";
					dynamic_pixel_bit_depth = "12";
					csi_pixel_bit_depth = "12";
					mode_type = "bayer";
					pixel_phase = "rggb";

					active_w = "1920";
					active_h = "1080";
					readout_orientation = "0";
					line_length = "2200";
					inherent_gain = "1";
					mclk_multiplier = "2";
					pix_clk_hz = "74250000";

					min_gain_val = "0"; /* dB */
					max_gain_val = "48"; /* dB */
					min_hdr_ratio = "1";
					max_hdr_ratio = "1";
					min_framerate = "1.5";
					max_framerate = "30";
					min_exp_time = "30";
					max_exp_time = "660000";
					embedded_metadata_height = "1";
			};
			mode1 {/*mode IMX185_MODE_1920X1200_30FPS*/
						mclk_khz = "37125";
						num_lanes = "4";
						tegra_sinterface = "serial_c";
						discontinuous_clk = "no";
						dpcm_enable = "false";
						cil_settletime = "0";
						dynamic_pixel_bit_depth = "12";
						csi_pixel_bit_depth = "12";
						mode_type = "bayer";
						pixel_phase = "rggb";

						active_w = "1920";
						active_h = "1200";
						readout_orientation = "0";
						line_length = "3750";
						inherent_gain = "1";
						mclk_multiplier = "4";
						pix_clk_hz = "148500000";

						min_gain_val = "0";
						max_gain_val = "48";
						min_hdr_ratio = "1";
						max_hdr_ratio = "1";
						min_framerate = "1.5";
						max_framerate = "30";
						min_exp_time = "30";
						max_exp_time = "660000";
						embedded_metadata_height = "1";
			};
			ports {
				#address-cells = <1>;
				#size-cells = <0>;
				port@0 {
					reg = <0>;
					imx185_out1: endpoint {
						csi-port = <2>;
						bus-width = <4>;
						remote-endpoint = <&csi_in1>;
					};
				};
			};
		};
	};
	lens_imx185@A6V24 {
		min_focus_distance = "0.0";
		hyper_focal = "0.0";
		focal_length = "5.00";
		f_number = "2.0";
		aperture = "2.2";
	};
};


